# 주어진 값들이 몇자리이든 일단 무조건 가장 앞자리가 큰 수가 와야한다.
# 주어진 숫자 리스트를 원소를 문자열로 이중 리스트로 만든다음 인덱스 0 기준으로 정렬하면... 
# 리스트 총 길이가 100,000 이고 원소가 1000 이면,,,,100,000,000 1억이니까 그냥 변환하고 소트시켜도 될듯? 어차피 소트는 십만인거임

#거기에 문자열로 바꾸어 리턴이니까 오히려좋아임

def solution(numbers):

    numbers = [str(num) for num in numbers] # 이러면 ["6",'10','2'] 가 되는데 문자열은 리스트죠?
    
    #그래서 sorted 함수를 쓰려는데, key값이 숫자화 된 원소문자열의 첫번째여야하는데, 이건 람다를 쓰거나 따로 함수 선언해서 소티드 밖에서 해줘야할듯
    # 난 람다 써볼게 lambda z,x : z+ x 하면 z+x된 값이 반환딤.
    
    # 근데 문제는 3,34,30 이 있으면 34를 반환해야함. 이 예외처리가 필요한데 간단하게 하는법 있을까?
    # 앞자리만 보지 말고 모든 숫자를 봐야할텐데...
    # 3 34 321 이렇게 있으면. 343321 이게 맞잖아? 이걸 어케할까...
    # 지금 생각나는건, 우선 첫번째 자리로 정렬 한 다음에, 앞자리가 같은 거는 또 비교해가면서 해가야할거같음. 그럼 함수가 2개는 필요할듯
    # 앞자리를 기준으로비교해서 정렬하는 함수, 앞자리는 같고 뒷자리가 달라지는 애들ㅇ ㅣ있는지 비교하는 함수. 근데 그럼 레벨 2 치고는 너무 구현할게 많은데..?
    # 근데 혹시 문자열로 정렬하면 좀 다른가?? 문자열 기준으로 정렬해보겠음. 
    
    # 와 풀이 15분만에 그냥 정답지 봤는데 새로운 해결 방법을 보게됨. *10 을 하면 차이가 명확해지잖아? 이걸 기준으로 하네. 천잰가? ?

 #그래서 따지고보면, 1000까지니까 한 3~5만 해도 안정적으로 나오긴함. 문자열 정렬이라는걸 기억해야함
    
    # 예외 11번 뭘까? 도대체? 
    # 0,0,0 이면 만들수 있는 가장 큰 수는 0이여야함. 
    

    numbers_sorted = sorted(numbers,key= lambda num :num*10 , reverse=True)
    #아니 근데 왜 안되냐 " 붙여줘야하냐?
    
    if numbers_sorted[0] == '0':
        return "0"
    answer = str(''.join(numbers_sorted))
    

    return answer